
객체(Object)
- 클래스에서 생성된 데이터

클래스(Class)
- 객체를 정의한 설계도/틀
- 객체를 생성하는 데 사용

메시지(Message)
- 오퍼레이션면+인자
ex) drink(water)

책임(Responsibility)
- 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는 데 집중돼야 한다. 
- 하나의 클래스에 여러 기능(책임)을 넣느냐 클래스를 분리하여 기능(책임)을 분산시키느냐의 설계

협력(Collaboration)
- 여러 객체들이 서로 메시지를 주고받으며 특정 작업을 함께 수행하는 것 

역할(Role)

상태(State)
- 객체가 가질 수 있는 조건이나 상황

행동(Behavior)
- 객체가 수행할 수 있는 동작이나 기능

캡슐화 (Encapsulation)
- 객체의 내부 구조 및 데이터를캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호

상속 (Inheritance)
- 기존 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것 

다형성 (Polymorphism)
- 코드는 변하지 않지만 기능이 변하는 것
- 한 가지의 코드로 여러 기능을 할 수 있다

추상화 (Abstraction)
- 클래스들의 공통적인 요소를 뽑아서 상위 클래스를 만들어내는 것

필드(Field)
- 클래스에 포함된 변수
- 객체의 속성을 정의하는 공간

메서드(Method)
- 특 기능을 수행하기 위한 코드들의 집합체

생성자(Constructor)
- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드
- new 연산자에 의해 호출됨

인스턴스(Instance)
- 클래스의 타입으로 선언됐을 때: 객체
- 그 객체가 메모리에 할당되어 실제 사용될 때: 인스턴스

인스턴스 변수
- 인스턴스가 생성될 때 만들어져 각 객체마다 고유한 상태를 가지는 변수

인스턴스 메서드
- 인스턴스에 속한 메소드
- 객체가 생성되어야만 호출 가능

클래스 변수(static)
- 메모리에 고정적으로 할당되어 프로그램이 종료될때까지 유지되는 변
- 객체를 생성하지 않고도 static 자원에 접근이 가능하다

클래스 메서드(static method)
- 객체 생성 없이 호출 가능
- Math.max()

객체 생성(new)
- 클래스 타입의 인스턴스를 생성해 주는 역할

this
- 객체 자신을 가리키는 레퍼런스 변수

객체 참조(reference)
- 메모리의 주소에 직접 접근하지 않도 메모리 주소에 접근할 수 있도록 하는 값

접근제어자
- 클래스와 클래스의 멤버를 사용할 때 접근할 수 있는 범위를 지정해주는 역할

public
- 모든 클래스에서 접근 가능

protected
- 같은 패키지 안의 모든 클래스 + 다른 패키지의 자식 클래스에 접근 가능

default(package-private)
- 같은 패키지 안의 클래서에서만 접근 가능

private
- 같은 클래스 안에서만 접근 가능

정보 은닉(Information Hiding)
- private 키워드를 활용해서 외부에서 클래스 내부의 정보에 접근하지 못하도록하는 기능

getter / setter
- getter: private을 외부로 꺼내는 메소드
- setter: private에 값을 넣는 메소드

불변 객체(Immutable Object)
- 생성 후 그 상태를 바꿀 수 없는 객체

extends
- 클래스 상속

부모 클래스 (Super class)
- 자식클래스가 물려받을 공통 속성과 기능을 정의하는 클래스

자식 클래스 (Sub class)
- 부모클래스의 기능을 물려받아 확장하거나 재정의할 수 있는 클래스

super
- 자신이 상속받은 부모 클래스에 대한 레퍼런스 변수

메서드 오버라이딩(Overriding)
- 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것

메서드 오버로딩(Overloading)
- 메소드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것

final (상속/오버라이딩 제한)
- 처음 정의된 상태가 변하지 않는 것을 보장

다중 상속 제한 (자바 특징)
- 상속의 모호성과 복잡성을 피하기 위함
(부모 중에서 어떤 메소드를 호출하는 건지 모호함, 코드의 복잡성)

부모 타입 참조
- 상속 관계에서 부모클래스 타입의 참조 변수로 자식 클래스의 객체를 가리키는 것
- 다형성이 가능해지도록

업캐스팅(Upcasting)
- 하위 클래스의 정보를 담을 수 있는 객체에 상위클래스의 자료형을 부여해서, 상위클래스처럼 사용하게 하는 것
ex) Parent p = new Child();

다운캐스팅(Downcasting)
- 하위클래스(Child)의 정보를 담을 수 있는 객체의 자료형이 상위클래스(Parent)로 전환되어 있던 것(업캐스팅된 객체)을 다시 되돌리는 것
ex) Child c = (Child) p;

instanceof
- 객체의 타입을 확인하는 연산자

동적 바인딩(Dynamic Binding)
- 런타임 시 수행되는 바인딩

런타임 다형성
- 메소드 오버라이딩을 통해 구현

컴파일 타임 다형성
- 메소드 오버로딩을 통해 구현

추상 클래스(Abstract Class)
- 실체 클래스의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스
- 앞에 abstract 키워드를 붙인다 

추상 메서드(Abstract Method)
- 추상 클래스에서만 선언할 수 있다
- 선언은 되어 있으나 코드가 구현되어 있지 않은 메소드

인터페이스(Interface)
- 다른 클래스를 작성할 경우 기본이 되는 틀을 제공하면서 다른 클래스 사이의 중간매개 역할을 하는 추상클래스

implements
- 인터페이스를 구현하는 키워드
- 여러 개의 인터페이스 상속 가능

default method (Java 8+)
- 인터페이스에 있는 구현 메소드
- 인터페이스에 자유롭게 새로운 메소드를 추가할 수 있다

다중 구현
- 하나의 클래스가 여러 개의 인터페이스를 implements 키워드를 통해 동시에 구현하는 것

의존성 분리
- 

Association (연관)
- 클래스 간의 관계를 표현하는 가장 기본적인 형태
- 서로 다른 클래스들이 연결되어 상호작용 하는 것

Aggregation (집합)
- 객체 간의 약한 결합을 나타내는 관계
- 두 객체는 독립적인 생명 주기를 가짐
ex) 학교와 학생: 학교 클래스가 여러 학생 객체를 포함하고 있을 때, 학교가 없어져도 학생들은 여전히 존재할 수 있음.

Composition (합성)
- 다른 클래스의 객체를 더 큰 클래스의 일부로 포함시키는 방
- 객체 간의 관계가 수직관계가 아닌 수평 관계가 된다

Dependency (의존)
- A가 B를 의존한다는 것 -> 의존 대상 B가 변화면 그것이 A에 영향을 미친다는 것

has-a 관계
- ~를 가지고 있다 / ~를 포함한다
ex) Car은 Engine을 가진다.

is-a 관계
- 상속을 의미
ex) 강아지 is a 동물

응집도(Cohesion)
- 한 모듈 내에 존재하는 함수, 데이터 등의 구성 요소들 사이의 밀집한 정도

결합도(Coupling)
- 하나의 모듈이 다른 모듈에 의존하는 정도 = 의존도

단일 책임 원칙(SRP)
- 객체는 단 하나의 책임만 가져야 한다는 원칙

개방-폐쇄 원칙(OCP)
- 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙

리스코프 치환 원칙(LSP)
- 부모 클래스의 행동 규약을 자식 클래스가 위반하면 안 된다는 것

인터페이스 분리 원칙(ISP)
- 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙

의존 역전 원칙(DIP)
- 고차원 모듈은 저차원 모듈에 의존하면 안된다. 두 모듈 모두 다른 추상화된 것에 의존해야 한다.

SOLID 원칙
- 좋은 객체 지향 설계의 5가지 원리
- 소프트웨어 개발을 유연하고 유지보수가 쉽게하기 위해 만들어진 원칙

객체 생명주기(Lifecycle)
- 생성-초기화-사용-소멸

의존성 주입(DI)
- 두 객체 간의 관계를 맺어주는 것

IoC (제어의 역전)
- 객체의 생성과 그 객체들의 관리까지 모두 관리
- IoC 컨테이너는 객체의 생성, 초기화, 소멸에 관한 모든 권한을 가지면서 객체의 생명주기를 관리 -> 제어권이 역전됨

디자인 패턴
- 프로그래밍에서 공통적인 문제를 쉽게 해결하기 위해 만들어진 가이드라인
- 재사용성, 유지보수성을 위해

전략 패턴
- 실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴

싱글톤
- 메모리 절약을 위해, 클래스의 객체를 한개만 생성해서 그 객체만을 사용하는 패턴

팩토리
- 객체 생성을 공장(Factory) 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴

템플릿 메서드
- 여러 클래스에서 공통으로 사용하는 메소드를 템플릿화하여 상위클래스에서 정의

도메인 모델
- 특정 문제와 관련된 모든 주제의 개념 모델

DTO / VO / Entity
- DTO: 계층(Layer)간 데이터 교환을 위해 사용하는 객체, 데이터 교환만을 위해 사용하므로 로직을 갖지 않고, getter/setter 메소드만 갖는다.
- VO: 값 그 자체를 표현하는 객체, 로직을 포함할 수 있으며, 객체의 불변성(객체의 정보가 변경하지 않음)을 보장
- Entity: DB의 테이블과 매핑되는 객체, id를 통해 각각의 Entity를 구분하고 VO와 마찬가지로 로직을 가질 수 있다.










