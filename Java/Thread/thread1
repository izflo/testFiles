[Account2]
//withdraw와 deposit이 this.money(같은 자원)를 공유
//동기화 안 하면 계좌잔액이 0이 안 나옴. (무조건 0이 나와야함.)
//출금에 대한 동기화 메소드
public synchronized void withdraw() {
  this.setMoney(this.getMoney() - 500);
}

// 입금에 대한 동기화 메소드
public synchronized void deposit() {
  this.setMoney(this.getMoney() + 500);
}





[HongThread2]
// 공용 자원에 대해 동기화 메소드 사용 (메소드내의 모든 객체에 대해 동기화됨)
// 객체 여러개 동기화
// hongAccount2.withdraw(); -> Account2에서 synchronized된 메소드를 사용하거나

// 공용 자원에 대해 동기화 블럭 사용 (블럭내에서는 hongAccount2 객체에 대해 동기화됨)
// 객체 하나만 동기화할 때
synchronized (hongAccount2) {
  hongAccount2.setMoney(hongAccount2.getMoney()-500); // 여기서 synchronized 블럭 안에서 바로 접근해서 사용하거나
}
			




[ThreadTest4]
//공용 계좌 생성
Account2 account2 = new Account2("커플계좌", 0);

// HongThread2와 KangThread2가 같은 Account2를 가지게 됨 (같은 자원 공유)
// 홍이 500원 10번 넣고 강이 500원 10번 빼면 최종 계좌가 0이 나와야하는데
// 동기화 안 하면 0이 안 나옴. -> ERROR!!!
new HongThread2(account2).start();
new KangThread2(account2).start();

try {
  Thread.sleep(1000); // > 위의 Thread 실행 한 다음
} catch (InterruptedException e) {
  e.printStackTrace();
}

System.out.println("최종 계좌 잔액 : "+account2.getMoney());




[Product]

/*
	Producer/Consumer 패턴 : 생산자는 생산만 하고 소비자는 소비만 하는 패턴
	생산과 소비가 순차적으로 일어남
 */

package thread;

public class Product {

	private String product; // 제품명

	// 제품을 생산하는 메소드
	public synchronized void produce(String product) {
		//이미 생산됐을 때
		while (this.product != null) {
			try {
				//나 만들었으니까 이제 consume아 너가 소비해
				wait(); //notify 불릴 때까지 (제품이 소비될 때까지) 대기 
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		} // while
		
		this.product = product;
		System.out.println("제품 생산 : " + product);
		notify(); // consume한테 제품을 소비하라고 알림
	}

	// 제품을 소비하는 메소드
	public synchronized String consume() {
		//이미 소비됐을 때
		while (this.product == null) {
			try {
				wait(); // notify 불릴 때까지 (생산할 때까지) 대기
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		} // while
		
		String result = this.product;
		this.product = null;
		System.out.println("제품 소비 : " + result);
		notify(); // produce한테 제품을 생산하라고 알림
		return result;
	}
}




[interrupt()]
try {
	// Thread를 종료하는 가장 좋은 방법은 조건에 따라
	// Thread를 interrupt > InterruptedException에서 처리
	if(i==10) this.interrupt();
	Thread.sleep(2000); // interrupt된 후에는 sleep에서 Exception이 실행됨
} catch (InterruptedException e) {
	System.out.println("### EvenThread 종료됨!"); //-> OddThread도 같이 종료됨
	System.exit(0); // 정상 종료
	e.printStackTrace();
}

