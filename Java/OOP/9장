- 상위로 갈수록 설계, 추상, 공통 / 하위로 갈수록 구현, 구체, 개별

-----

    // 상위타입 객체참조변수에 하위타입 객체참조값을 할당
		// => 하위타입들을 상위타입으로 "타입 일원화" 가능***
		Parent child = new Child();
		
		// 모든 객체참조는 Object 객체참조변수에 저장 가능
		// child2는 Parent의 변수,메소드가 없음
		Object child2 = new Child();
		
		// 상위타입인 Parent의 private이 아닌 멤버변수를 하위타입에서 상속받음
		System.out.println(child.si);
		System.out.println(child.nsi);
		
		 // 상위타입인 Parent의 private이 아닌 멤버메서드를 하위타입에서 상속 받음
	      child.sm();
	      child.nsm();

-----

public class Parent /*extends Object 생략*/ {

}

-----

[오버라이딩]
- Vehicle bus = new Bus();
- 타입 일원화
- Bus는 Vehicle이기도함. Bus는 앞으로 Vehicle 타입으로 부르기로함.
- Vehicle 타입으로 관리할 수 있으니까. -> 비슷한 애들을 모아두고 관리
- Bus, Bicyle, Airplane 각각 1000개씩 만드는 게 아니라 Vehicle로 3000개 만들어서 각각 Bus, Bicyle, Airplane을 넣어줌
- Vehicle로 만들어도 하위에서 동일 메소드에 대해 오버라이딩을 해놓으면 각각 다른 구현을 할 수 있게 만들어줌 -> 다 다른 버스, 자전거, 비행기여도 Vehicle하나로 관리할 수 있음
- @Override : 오버라이딩한 메소드인지 컴파일타임에 검증하는 어노테이션(annotation)

-----

		// 아래 v1, v2, v3 변수는 모두 Vehicle 타입이나 가지고 있는 참조는 모두 다름
		// => 다형성 : 동일한 형태인데 다른 성질을 가짐
    
		// 오버라이딩의 목적
		// 상위타입 객체참조변수에 하위타입 객체참조값을 저장하면
		// 하위타입들을 하나의 상위타입으로 "타입 일원화" 할 수 있음
		
		// v1 변수는 Vehicle타입, 가지고 있는 참조는 Vehicle참조
		Vehicle v1 = new Vehicle("탈것", false);
		System.out.println(v1); //Vehicle의 toString호출
		
		// v2 변수는 Vehicle타입, 가지고 있는 참조는 Bus참조
		Vehicle v2 = new Bus(true, 25);
		System.out.println(v2); //Bus의 toString호출
				
		// v3 변수는 Vehicle타입, 가지고 있는 참조는 Bicycle참조
		Vehicle v3 = new Bicycle(true, false);
		System.out.println(v3); //Vehicle의 toString호출


-----
    // 실습
		// name이 Bus1~Bus1000인 1000개의 Bus객체를 생성
		// name이 Bicycle1~Bicycle1000인 1000개의 Bicycle객체를 생성
		// name이 Airplane1~Airplane1000인 1000개의 Airplane객체를 생성
		// 생성된 3000개의 객체의 이름을 출력

		Vehicle[][] v = new Vehicle[3][1000];

		for (int i = 0; i < 1000; i++) {
			v[0][i] = new Bus("Bus" + (i + 1));
			v[1][i] = new Bicycle("Bicycle" + (i + 1));
			v[2][i] = new Airplane("Airplane" + (i + 1));
		}

		for (Vehicle[] va : v) {
			for (Vehicle vi : va) {
				System.out.println(vi.getName());
			}
		}
		
    // better code
    // Bus, Bicycle, Airplane 모두 Vehicle 타입이다! 상위타입으로 일원화!***
    int cnt = 3000;
    Vehicle[] vArr = new Vehicle[cnt];
    for (int i=0; i<cnt; i=i+3) {
       vArr[i] = new Bus("Bus" + (i/3+1), true, 25);
       vArr[i+1] = new Bicycle("Bicycle" + (i/3+1), true, false);
       vArr[i+2] = new Airplane("Airplane" + (i/3+1), true, 2);
    }
    for (Vehicle v : vArr) {
       System.out.println(v.getName());
    }

    -----

    상속은 is a
      ㄴ Bus is a Vehicle
      ㄴ 아빠는 교체할 수 없음
      
    집합은 has a
      ㄴ 관계를 느슨하게 하려고
      ㄴ 언제든 교체할 수 있음 : 친구는 맘에 안들면 교체할 수 있음
    class PC {
      Monitor mon;
    }

-----
		// 실습
		// Vehicle의 기본 요금은 1000원
		// Bus 요금은 Vehicle 기본 요금의 1.5배
		// Bicycle 요금은 Vehicle 기본 요금의 0.5배
		// Airplane 요금은 Vehicle 기본 요금의 30배
		// 3명이 Bus를 타고 5명이 Bicycle을 타고 2명이 Airplane을
		// 탄다고 했을 때 총 요금을 연산

[내코드]
 		  int passengers = 10;
	      Vehicle[] v = new Vehicle[passengers];
	      v[0] = new Bus();
	      v[1] = new Bus();
	      v[2] = new Bus();
	      v[3] = new Bicycle();
	      v[4] = new Bicycle();
	      v[5] = new Bicycle();
	      v[6] = new Bicycle();
	      v[7] = new Bicycle();
	      v[8] = new Airplane();
	      v[9] = new Airplane();
	      
	      double sum = 0;
	      
	      for(Vehicle vv : v) {
	    	  sum+= vv.getPrice();
	      }
	      System.out.println(sum);

**** 기존 클래스는 최대한 건들이지 않는 게 좋음 / 모듈은 모듈 자체로 냅둬야함 => 모듈화를 위해서 ****
		Vehicle vv = new Vehicle();		
		vv.setPrice(1000);
		Vehicle bu = new Bus();				
		bu.setPrice((int)(vv.getPrice() * 1.5));
		Vehicle bi = new Bicycle();			
		bi.setPrice((int)(vv.getPrice() * 0.5));
		Vehicle ai = new Airplane();		
		ai.setPrice(vv.getPrice() * 30);
		
		Vehicle[] vvArr = {bu, bu, bu, bi, bi, bi, bi, bi, ai, ai}; // 전부 다 Vehicle타입
							ㄴ 계산만을 위한거라 새롭게 객체 생성 하지 않음.
		
		int priceSum = 0;
		for (Vehicle v : vvArr) {
			priceSum += v.getPrice();
		}
		
		System.out.printf("요금 총합 : %d", priceSum);

