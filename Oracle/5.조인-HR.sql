-- 조인 : 두 개 이상의 테이블에서 데이터를 조회

-- CATESIAN JOIN (CROSS JOIN)
-- 양쪽 테이블의 모든 행의 조합을 조회
-- 예를 들어, A테이블에 50개 행이 있고 B테이블에 30개 행이 있다면 결과는 1500개 행의 결과

SELECT COUNT(*) FROM EMPLOYEES; --107
SELECT COUNT(*) FROM DEPARTMENTS; --27

SELECT COUNT(*)
FROM EMPLOYEES E, DEPARTMENTS D; -- 107 * 27 = 2889개 행

-- INNER JOIN (EQUI JOIN)
-- 양쪽 테이블의 [같은 값]을 가진 컬럼을 기준으로 조인
-- 조인 컬럼 : 같은 값을 가지는 컬럼 (PK-FK)
-- 조인 조건 : 양쪽 조인 컬럼의 값이 같다

-- ORACLE INNER JOIN 문법
SELECT COUNT(*)
FROM EMPLOYEES E, DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 106개 행
-- EMPLOYEES테이블의 DEPARTMENT_ID가 NULL인 행이 하나 있음

-- ANSI JOIN 문법
-- 모든 DBMS에서 사용 가능
SELECT COUNT(*)
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 106개 행

-- 조인 후 추가 조건
-- 두 테이블을 INNER JOIN하는데, 부서아이디가 50인 것만 조회
SELECT *
FROM EMPLOYEES E, DEPARTMENTS D
WHERE 
	E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND D.DEPARTMENT_ID = 50; -- 45행
	
-- 실습1) COUNTRIES와 LOCATIONS를 INNER JOIN
SELECT *
FROM COUNTRIES C JOIN LOCATIONS L
ON L.COUNTRY_ID = C.COUNTRY_ID; -- 23행

-- 실습2) 실습 1의 결과에서 국가명이 Italy인 행만 조회
SELECT *
FROM COUNTRIES C JOIN LOCATIONS L
ON L.COUNTRY_ID = C.COUNTRY_ID
	AND C.COUNTRY_NAME = 'Italy'; -- 2행

-- 실습3) EMPLOYEES, JOB_HISTORY, JOBS를 INNER JOIN
--SELECT *
--FROM EMPLOYEES E
--JOIN JOB_HISTORY JH
--ON  JH.JOB_ID = E.JOB_ID
--JOIN JOBS J
--ON J.JOB_ID = E.JOB_ID;

SELECT *
FROM EMPLOYEES E, JOB_HISTORY JH, JOBS J
WHERE
	E.EMPLOYEE_ID = JH.EMPLOYEE_ID 
	AND JH.JOB_ID = J.JOB_ID ; -- 10행
	
-- ANSI
SELECT *
FROM EMPLOYEES E
	JOIN JOB_HISTORY JH
	ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID 
	JOIN JOBS J
	ON JH.JOB_ID = J.JOB_ID ; -- 10행

-- OUTER JOIN
-- 조인하려는 한 쪽 테이블에 해당하는 값이 없어도 조회 결과에 포함됨
-- LEFT OUTER JOIN
--	ㄴ 오른쪽 테이블에 해당하는 값이 없어도 [왼쪽 테이블의 행은 모두 조회하도록]
-- RIGHT OUTER JOIN
--	ㄴ 왼쪽 테이블에 해당하는 값이 없어도 오른쪽 테이블의 행은 모두 조회하도록
-- FULL OUTER JOIN
--	ㄴ 양쪽 테이블에 해당하는 값이 없어도 양쪽 테이블의 행은 모두 조회하도록
	
-- EMPLOYEES, DEPARTMENTS에서 DEPARTMENT_ID가 NULL인 행의 개수
SELECT COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL; -- 1

SELECT COUNT(*)
FROM DEPARTMENTS
WHERE DEPARTMENT_ID IS NULL; -- 0

-- LEFT OUTER JOIN
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+); -- 107행
-- D.DEPARTMENT_ID를 증가시켜서라도 행의 갯수를 맞추려하는데 D.DEPARTMENT_ID는 증가시킬 게 없음

-- ANSI
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 107행

-- RIGHT OUTER JOIN
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID; -- 122행
--E.DEPARTMENT_ID를 증가시켜서라도 오른쪽께 다 나와야함

-- ANSI 
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 122행

-- FULL OUTER JOIN
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 123행

-- FULL OUTER JOIN에서 LEFT OUTER JOIN 뺀 결과
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
MINUS
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 16행


-- FULL OUTER JOIN에서 RIGHT OUTER JOIN 뺀 결과
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
MINUS
SELECT E.EMPLOYEE_ID , D.DEPARTMENT_ID 
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; -- 1행

-- SELF JOIN
-- 물리적으로 하나의 테이블을 논리적으로 두개로 놓고 조인
SELECT E1.EMPLOYEE_ID , E2.EMPLOYEE_ID 
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.MANAGER_ID=E2.EMPLOYEE_ID ;

-- 실습) MANAGER_ID가 100번인 직원들의 정보를 SELF JOIN을 이용해 조회
SELECT E1.EMPLOYEE_ID EID, E2.EMPLOYEE_ID MID
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE 
	E1.MANAGER_ID=E2.EMPLOYEE_ID
	AND E1.MANAGER_ID = 100;