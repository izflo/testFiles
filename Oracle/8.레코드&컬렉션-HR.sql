/*
 레코드 : 서로 다른 타입들을 하나로 묶은 타입
 - 일반적으로 테이블이나 조인결과의 전체나 일부 컬럼들의 타입을 하나로 묶기 위해 사용
 - %ROWTYPE : 테이블의 한 행에 있는 모든 컬럼의 타입을 묶은 시스템 레코드타입
 - 구문 형식
   TYPE 레코드타입명 IS RECORD (
   	변수명 변수타입 [NOT NULL][ := 값];
   	변수명 변수타입 [NOT NULL][ := 값];
   	...
   );
*/

DECLARE
	-- 레코드타입 선언
	TYPE REC_DEPT IS RECORD (
		DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
		DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
	);
	-- 레코드 타입 변수 선언
	V_REC_DEPT REC_DEPT;
BEGIN
	SELECT DEPARTMENT_ID, DEPARTMENT_NAME
	INTO V_REC_DEPT.DEPT_ID, V_REC_DEPT.DEPT_NAME
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 100;
	PL(V_REC_DEPT.DEPT_ID||' '||V_REC_DEPT.DEPT_NAME);
END;

-- 중첩레코드 타입 (레코드타입이 레코드타입을 포함)
DECLARE
  TYPE REC_EMP IS RECORD (
	EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
	EMP_FULLNAME VARCHAR2(46)
  );
  TYPE REC_DEPT IS RECORD (
	DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
	DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME% TYPE,
	V_REC_EMP REC_EMP -- 레코드타입 내에 레코드 타입이 중첩
  );
  V_REC_DEPT REC_DEPT;
BEGIN
  SELECT 
  D.DEPARTMENT_ID, 
  D.DEPARTMENT_NAME, 
  E.EMPLOYEE_ID, 
  E.FIRST_NAME||' '||E.LAST_NAME
  INTO 
  V_REC_DEPT.DEPT_ID,
  V_REC_DEPT.DNTEEPT_NAME,
  V_REC_DEPT.V_REC_EMP.EMP_ID,
  V_REC_DEPT.V_REC_EMP.EMP_FULLNAME
  FROM EMPLOYEES E, DEPARTMENTS D
  WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
  	AND E.EMPLOYEE_ID = 110;
  PL(V_REC_DEPT.DEPT_ID);
  PL(V_REC_DEPT.DEPT_NAME);
  PL(V_REC_DEPT.V_REC_EMP.EMP_ID);
  PL(V_REC_DEPT.V_REC_EMP.EMP_FULLNAME);
END;


/*
 COLLECTION : 동일한 타입의 값을 여러개 저장할 목적의 타입
 - 실무에서는 컬렉션에 레코드들을 담아서 많이 사용 (JAVA에서 LIST안에 객체들을 저장해서 사용하는 것처럼)
 - 일반적으로 레코드는 하나의 행의 데이터를 저장, 컬렉션은 레코드들을 저장
 - 컬렉션 분류
	1) 연관 배열 (ASSOCIATIVE ARRAY) : 숫자나 문자를 키로 하고 키마다 값을 매핑한 타입
	2) 중첩 테이블 (NESTED TABLE) : 숫자를 키로 하고 키마다 값을 매핑한 타입
	3) VARRAY : 동일한 타입의 값들을 모아놓은 타입 (LIKE 배열, 잘 안씀)
*/

--연관 배열
DECLARE
	-- 정수를 인덱스로 사용하는 VARCHAR2(20) 타입들을 묶은 연관배열 타입
	TYPE AA_STRING IS TABLE OF VARCHAR2(20)
	INDEX BY PLS_INTEGER;
	-- 연관배열 타입 변수 선언
	V_AA_STRING AA_STRING;
BEGIN
	-- 연관배열 변수에 인덱스와 값을 저장
	V_AA_STRING(1) := '홍길동';
	V_AA_STRING(2) := '강감찬';
	V_AA_STRING(3) := '이순신';
	PL(V_AA_STRING(1));
	PL(V_AA_STRING(2));
	PL(V_AA_STRING(3));
END;

-- RECORD 들의 연관배열
DECLARE
	 --정수를 인덱스로 하고  DEPARTMENTS테이블의 행들을 저장하는 연관배열
	TYPE AA_DEPT IS TABLE OF DEPARTMENTS%ROWTYPE
	INDEX BY PLS_INTEGER;
	-- 연관배열 타입 변수 선언
	V_AA_DEPT AA_DEPT;
	-- 레코드 타입의 변수 선언
	V_DEPT50 DEPARTMENTS%ROWTYPE;
	V_DEPT60 DEPARTMENTS%ROWTYPE;
BEGIN
	SELECT * INTO V_DEPT50 FROM DEPARTMENTS WHERE DEPARTMENT_ID=50;
	SELECT * INTO V_DEPT60 FROM DEPARTMENTS WHERE DEPARTMENT_ID=60;
	V_AA_DEPT(1) := V_DEPT50;
	V_AA_DEPT(2) := V_DEPT60;
	PL(V_AA_DEPT(1).DEPARTMENT_ID||' '||V_AA_DEPT(1).DEPARTMENT_NAME);
	PL(V_AA_DEPT(2).DEPARTMENT_ID||' '||V_AA_DEPT(2).DEPARTMENT_NAME);
END;

-- EMPLOYEES테이블의 사원 풀네임을 키로 하고 행을 값으로 하는 연관배열
DECLARE
  TYPE AA_EMP IS TABLE OF EMPLOYEES%ROWTYPE
  INDEX BY VARCHAR2(46);
  V_AA_EMP AA_EMP;
  -- EMPLOYEES테이블의 조회 결과 행동을 지칭하는 커서 선언
  CURSOR CUR_EMP IS (
	SELECT * FROM EMPLOYEES
  );
  V_FULLNAME VARCHAR2(46);
BEGIN
	-- 커서가 지칭하는 행의 수만큼 반복 (각 행의 데이터를 EACHROW에 저장하면서)
	FOR EACHROW IN CUR_EMP
	LOOP
		V_FULLNAME := EACHROW.FIRST_NAME||' '||EACHROW.LAST_NAME;
		V_AA_EMP(V_FULLNAME) := EACHROW; -- 인덱스가 풀네임, 값이 행
		PL(V_AA_EMP(V_FULLNAME).FIRST_NAME);
		PL(V_AA_EMP(V_FULLNAME).SALARY);
	END LOOP;
END;

-- 중첩테이블
DECLARE
	--EMPLOYEES의 행들을 저장하는 NT_EMP라는 이름의 중첩테이블 타입
	TYPE NT_EMP IS TABLE OF EMPLOYEES%ROWTYPE;
	-- 중첩테이블 타입의 변수를 선언
	V_NT_EMP NT_EMP;
BEGIN
	-- 비어있는 중첩테이블 생성
	V_NT_EMP := NT_EMP();
	FOR EACHROW IN (SELECT * FROM EMPLOYEES) -- SELECT ... => 익명 커서
	LOOP
		-- 중첩테이블에 공간 추가
		V_NT_EMP.EXTEND;		
		-- 추가된 공간에 행을 추가
		V_NT_EMP(V_NT_EMP.LAST) := EACHROW;
		PL(
			V_NT_EMP(V_NT_EMP.LAST).EMPLOYEE_ID||' '||
			V_NT_EMP(V_NT_EMP.LAST).FIRST_NAME||' '||
			V_NT_EMP(V_NT_EMP.LAST).LAST_NAME||' '||
			V_NT_EMP(V_NT_EMP.LAST).SALARY
		);
	END LOOP;
END;

-- VARRAY
DECLARE
	-- DEPARTMENTS의 DEPARTMENT_NAME 타입을 100개 저장할 수 있는 VARRAY타입 선언
	TYPE VA_NAME IS VARRAY(100)
	OF DEPARTMENTS.DEPARTMENT_NAME%TYPE;
	-- VARRAY타입의 변수 선언
	V_VA_NAME VA_NAME;
BEGIN
	-- 비어있는 VARRAY 생성
	V_VA_NAME := VA_NAME();
	FOR EACHROW IN (SELECT * FROM DEPARTMENTS)
	LOOP
		-- VARRAY 공간 추가
		V_VA_NAME.EXTEND;
		V_VA_NAME(V_VA_NAME.LAST) := EACHROW.DEPARTMENT_NAME;
		PL(V_VA_NAME(V_VA_NAME.LAST));
	END LOOP;
END;